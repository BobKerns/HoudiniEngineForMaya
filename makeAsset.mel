source createAndAssignShader;

proc string getTransformNode( string $shape )
{
    string $transform = "";

    if ( "transform" != `nodeType $shape` )
        // If given node is already a transform, just pass on through
    {
        string $parents[] = `listRelatives -fullPath -parent $shape`;
        $transform = $parents[0];
    }

    if ($transform == "")
        return $transform;
    return `substring $transform 2 (size($transform))`;
}


proc string getMaterialNode(string $shape)
{
    string $SGs[] = `listConnections -type shadingEngine $shape`;
    string $surfaceShader[] = `listConnections ($SGs[0] + ".surfaceShader")`;
    return $surfaceShader[0];
}


global proc makeAsset(string $fileName) {
    string $asset = `createNode hAsset`;
    setAttr -type "string" ($asset + ".fileName") $fileName;
    setAttr -lock on ($asset + ".fileName");

    // TODO: this is a hack, getting the attribute once sometimes returns
    // wrong result, getting it again seem to return correct result.
    int $numObjects = `getAttr ($asset + ".numberOfObjects")`;
    $numObjects = `getAttr -size ($asset + ".objects")`;

    print $numObjects;

    string $objects[] = {};
    for ($i=0; $i<$numObjects; $i++) {
        string $mesh = `getAttr ($asset + ".objects[" + $i + "].objectName")` + "Shape";
        createNode mesh -n $mesh;
        connectAttr ($asset + ".objects[" + $i + "].mesh") ($mesh + ".inMesh");

        string $transform = getTransformNode($mesh);
        $objects[size($objects)] = $transform;
        connectAttr ($asset + ".objects[" + $i + "].transform.translate") ($transform + ".translate");
        connectAttr ($asset + ".objects[" + $i + "].transform.rotate") ($transform + ".rotate");
        connectAttr ($asset + ".objects[" + $i + "].transform.scale") ($transform + ".scale");

        string $tmp = "assignCreatedShader %type \"" + $mesh + "\" %node \"" + $mesh + "\"";
        createRenderNodeCB -asShader "surfaceShader" phong $tmp;

        int $matExists = `getAttr ($asset + ".objects[" + $i + "].materialExists")`;
        if ($matExists)
        {
            string $material = getMaterialNode($mesh);
            connectAttr ($asset + ".objects[" + $i + "].material.specularColor") ($material + ".specularColor");

            string $texturePath= `getAttr ($asset + ".objects[" + $i + "].texturePath")`;
            if ($texturePath == "")
            {
                connectAttr ($asset + ".objects[" + $i + "].material.ambientColor") ($material + ".ambientColor");
                connectAttr ($asset + ".objects[" + $i + "].material.diffuseColor") ($material + ".color");
            } else
            {
                string $fileNode = `createRenderNodeCB -as2DTexture "" "file" ""`;
                connectAttr ($asset + ".objects[" + $i + "].material.texturePath")($fileNode + ".fileTextureName");
                connectAttr ($fileNode + ".outColor") ($material + ".color");
            }
        }

    }

    int $numInstancers = `getAttr -size ($asset + ".instancers")`;
    for ($i=0; $i<$numInstancers; $i++) {
        string $instancer = `createNode instancer`;
        $objects[size($objects)] = $instancer;
        setAttr ($instancer + ".rotationAngleUnits") 1;
        connectAttr ($asset + ".instancers[" + $i + "].instancerData") ($instancer + ".inputPoints");

        int $numInstObjNames = `getAttr -size ($asset + ".instancers[" + $i + "].ion")`;
        for ($j=0; $j<$numInstObjNames; $j++) {
            string $obj = `getAttr ($asset + ".instancers[" + $i + "].ion[" + $j + "]")`;
            connectAttr ($obj + ".matrix") ($instancer + ".inputHierarchy[" + $j + "]");
        }
    }

    if ($numObjects <= 0)
        return;

    // group the objects to be under one transform
    string $cmd = "group -n " + $asset + "Transform";
    for ($i=0; $i<size($objects); $i++) {
        $cmd += " ";
        $cmd += $objects[$i];
    }
    eval $cmd;

    refreshEditorTemplates;

}

