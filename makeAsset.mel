source createAndAssignShader;

proc string getTransformNode( string $shape )
{
    string $transform = "";

    if ( "transform" != `nodeType $shape` )
        // If given node is already a transform, just pass on through
    {
        string $parents[] = `listRelatives -fullPath -parent $shape`;
        $transform = $parents[0];
    }

    return $transform;
    //if ($transform == "")
        //return $transform;
    //return `substring $transform 2 (size($transform))`;
}


proc string getMaterialNode(string $shape)
{
    string $SGs[] = `listConnections -type shadingEngine $shape`;
    string $surfaceShader[] = `listConnections ($SGs[0] + ".surfaceShader")`;
    return $surfaceShader[0];
}


proc string[] getRelatedNodes(string $shape)
{
    string $ret[];
    if ($shape != "")
        $ret[size($ret)] = $shape;

    string $mat = getMaterialNode($shape);
    if ($mat != "")
        $ret[size($ret)] = $mat;

    string $trans = getTransformNode($shape);
    if ($trans != "")
        $ret[size($ret)] = $trans;
    
    string $tmp[] = `listConnections -s false -type shadingEngine ($mat + ".outColor")`;
    if (size($tmp) > 0)
        $ret[size($ret)] = $tmp[0];

    $tmp = `listConnections -d false -type file ($mat + ".color")`;
    if (size($tmp) > 0)
    {
        string $file = $tmp[0];
        $ret[size($ret)] = $file;
        $tmp = `listConnections -d false -type place2dTexture $file`;
        if (size($tmp) > 0)
            $ret[size($ret)] = $tmp[0];
    }
    return $ret;
}


proc disconnectFromObjects(string $objects[])
{
    for ($i=0; $i<size($objects); $i++)
    {
        string $plugs[] = `listConnections -sh true -d false -plugs true $objects[$i]`;
        for ($j=0; $j<size($plugs); $j++)
        {
            string $otherPlugs[] = `connectionInfo -dfs $plugs[$j]`;
            for ($k=0; $k<size($otherPlugs); $k++)
                disconnectAttr $plugs[$j] $otherPlugs[$k];
        }
    }
}


global proc string makeAsset(string $fileName) {
    string $tmpArray[] = stringToStringArray($fileName, "/");
    string $tmpStr = $tmpArray[size($tmpArray)-1];
    $tmpArray = stringToStringArray($tmpStr, ".");
    string $asset = $tmpArray[0] + "_asset";
    $asset = `createNode hAsset -n $asset`;
    setAttr -type "string" ($asset + ".fileName") $fileName;
    setAttr -lock on ($asset + ".fileName");

    //updateAsset($asset);

    // hack to get node to compute
    // TODO: move initialization to postConstructor
    getAttr ($asset + ".output");
    int $numObjects = `getAttr -size ($asset + ".objects")`;

    print $numObjects;

    string $objects[] = {};
    for ($i=0; $i<$numObjects; $i++) {
        string $mesh = `getAttr ($asset + ".objects[" + $i + "].objectName")` + "Shape";
        $mesh = `createNode mesh -n $mesh`;
        connectAttr ($asset + ".objects[" + $i + "].mesh") ($mesh + ".inMesh");

        string $transform = getTransformNode($mesh);
        $objects[size($objects)] = $transform;
        connectAttr ($asset + ".objects[" + $i + "].transform.translate") ($transform + ".translate");
        connectAttr ($asset + ".objects[" + $i + "].transform.rotate") ($transform + ".rotate");
        connectAttr ($asset + ".objects[" + $i + "].transform.scale") ($transform + ".scale");

        string $tmp = "assignCreatedShader %type \"" + $mesh + "\" %node \"" + $mesh + "\"";
        createRenderNodeCB -asShader "surfaceShader" phong $tmp;

        int $matExists = `getAttr ($asset + ".objects[" + $i + "].materialExists")`;
        if ($matExists)
        {
            string $material = getMaterialNode($mesh);
            connectAttr ($asset + ".objects[" + $i + "].material.specularColor") ($material + ".specularColor");

            string $texturePath= `getAttr ($asset + ".objects[" + $i + "].texturePath")`;
            if ($texturePath == "")
            {
                connectAttr ($asset + ".objects[" + $i + "].material.ambientColor") ($material + ".ambientColor");
                connectAttr ($asset + ".objects[" + $i + "].material.diffuseColor") ($material + ".color");
            } else
            {
                string $fileNode = `createRenderNodeCB -as2DTexture "" "file" ""`;
                connectAttr ($asset + ".objects[" + $i + "].material.texturePath")($fileNode + ".fileTextureName");
                connectAttr ($fileNode + ".outColor") ($material + ".color");
            }
        }

    }

    int $numInstancers = `getAttr -size ($asset + ".instancers")`;
    for ($i=0; $i<$numInstancers; $i++) {
        string $instancer = `createNode instancer`;
        $objects[size($objects)] = $instancer;
        setAttr ($instancer + ".rotationAngleUnits") 1;
        connectAttr ($asset + ".instancers[" + $i + "].instancerData") ($instancer + ".inputPoints");

        int $numInstObjNames = `getAttr -size ($asset + ".instancers[" + $i + "].ion")`;
        for ($j=0; $j<$numInstObjNames; $j++) {
            string $obj = `getAttr ($asset + ".instancers[" + $i + "].ion[" + $j + "]")`;
            connectAttr ($obj + ".matrix") ($instancer + ".inputHierarchy[" + $j + "]");
        }
    }

    if ($numObjects > 0)
    {
        // group the objects to be under one transform
        string $cmd = "group -n " + $asset + "_transform";
        for ($i=0; $i<size($objects); $i++) {
            $cmd += " ";
            $cmd += $objects[$i];
        }
        eval $cmd;
    }

    refreshEditorTemplates;

    return $asset;
}


global proc updateAsset(string $asset, int $numObjects)
{
    if (!`objExists $asset`)
        return;

    if (`getAttr ($asset + ".fileName")` == "")
        return;

    print "updated asset: ";
    print ($asset + "\n");

    // force compute if nothing is connected
    //string $tmp[] = `listConnections -s false $asset`;
    //if (size($tmp) == 0)
    //{
        //print ("Force compute ****" + "\n");
        //getAttr ($asset + ".output");
    //}
        ////getAttr ($asset + ".output");
    //int $numObjects = `getAttr -size ($asset + ".objects")`;

    print ($numObjects + "\n");

    string $objects[] = {};
    for ($i=0; $i<$numObjects; $i++) {
        string $obj = $asset + ".objects[" + $i + "]";
        string $objName = `getAttr ($obj + ".objectName")`;
        print ("objName: " + $objName + "\n");
        string $mesh = $objName + "Shape";
        $objects[size($objects)] = $objName;
        if (`objExists $mesh`)
        {
            //if (`connectionInfo -dfs ($obj + ".mesh")` == ($mesh + ".inMesh"))
            continue;
        }

        $mesh = `createNode mesh -n $mesh`;
        connectAttr ($obj + ".mesh") ($mesh + ".inMesh");

        string $transform = getTransformNode($mesh);
        connectAttr ($obj + ".transform.translate") ($transform + ".translate");
        connectAttr ($obj + ".transform.rotate") ($transform + ".rotate");
        connectAttr ($obj + ".transform.scale") ($transform + ".scale");

        string $tmp = "assignCreatedShader %type \"" + $mesh + "\" %node \"" + $mesh + "\"";
        createRenderNodeCB -asShader "surfaceShader" phong $tmp;

        int $matExists = `getAttr ($obj + ".materialExists")`;
        if ($matExists)
        {
            string $material = getMaterialNode($mesh);
            connectAttr ($obj + ".material.specularColor") ($material + ".specularColor");

            string $texturePath= `getAttr ($asset + ".objects[" + $i + "].texturePath")`;
            if ($texturePath == "")
            {
                connectAttr ($obj + ".material.ambientColor") ($material + ".ambientColor");
                connectAttr ($obj + ".material.diffuseColor") ($material + ".color");
            } else
            {
                string $fileNode = `createRenderNodeCB -as2DTexture "" "file" ""`;
                connectAttr ($obj + ".material.texturePath")($fileNode + ".fileTextureName");
                connectAttr ($fileNode + ".outColor") ($material + ".color");
            }
        }

        string $group = $asset + "_transform";
        if (!`objExists $group`)
            group -n $group -em;
        parent $objName $group;

    }

    string $connectedObjs[] = `listConnections -s false -t "mesh" $asset`;
    for ($i=0; $i<size($connectedObjs); $i++)
    {
        string $obj = $connectedObjs[$i];
        print ("obj: " + $obj + "\n");
        print "objects: ";
        print ($objects);
        print "\n";
        int $objIndex = stringArrayFind($obj, 0, $objects);
        print ("objIndex: " + $objIndex + "\n");
        if ($objIndex < 0)
        {
            string $mesh = $obj + "Shape";
            string $related[] = getRelatedNodes($mesh);
            disconnectFromObjects($related);
            for ($j=0; $j<size($related); $j++)
            {
                delete $related[$j];
            }
        }
    }

    //int $numInstancers = `getAttr -size ($asset + ".instancers")`;
    //for ($i=0; $i<$numInstancers; $i++) {
        //string $instancer = "instancer" + ($i + 1);
        //if (`objExists $instancer`)
        //{
            //continue;
        //}
        //$instancer = `createNode instancer`;
        //$objects[size($objects)] = $instancer;
        //setAttr ($instancer + ".rotationAngleUnits") 1;
        //connectAttr ($asset + ".instancers[" + $i + "].instancerData") ($instancer + ".inputPoints");

        //int $numInstObjNames = `getAttr -size ($asset + ".instancers[" + $i + "].ion")`;
        //for ($j=0; $j<$numInstObjNames; $j++) {
            //string $obj = `getAttr ($asset + ".instancers[" + $i + "].ion[" + $j + "]")`;
            //connectAttr ($obj + ".matrix") ($instancer + ".inputHierarchy[" + $j + "]");
        //}
    //}

    //if ($numObjects <= 0)
        //return;

    //// group the objects to be under one transform
    //string $cmd = "group -n " + $asset + "Transform";
    //for ($i=0; $i<size($objects); $i++) {
        //$cmd += " ";
        //$cmd += $objects[$i];
    //}
    //eval $cmd;

    //refreshEditorTemplates;
}
