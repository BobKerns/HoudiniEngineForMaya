source createAndAssignShader;

proc string getTransformNode( string $shape )
{
    string $transform = "";

    if ( "transform" != `nodeType $shape` )
        // If given node is already a transform, just pass on through
    {
        string $parents[] = `listRelatives -fullPath -parent $shape`;
        $transform = $parents[0];
    }

    if ($transform == "")
        return $transform;
    return `substring $transform 2 (size($transform))`;
}


proc string getMaterialNode(string $shape)
{
    string $SGs[] = `listConnections -type shadingEngine $shape`;
    string $surfaceShader[] = `listConnections ($SGs[0] + ".surfaceShader")`;
    return $surfaceShader[0];
}


proc renderNodeCallback(string $mesh)
{
}


global proc makeAsset(string $fileName) {
    string $asset = `createNode hAsset`;
    setAttr -type "string" ($asset + ".fileName") $fileName;
    setAttr -lock on ($asset + ".fileName");

    // TODO: this is a hack, getting the attribute once sometimes returns
    // wrong result, getting it again seem to return correct result.
    int $numObjects = `getAttr ($asset + ".numberOfObjects")`;
    $numObjects = `getAttr ($asset + ".numberOfObjects")`;

    print $numObjects;

    string $transforms[] = {};
    for ($i=0; $i<$numObjects; $i++) {
        string $mesh = $asset + "Mesh" + $i;
        createNode mesh -n $mesh;
        connectAttr ($asset + ".output[" + $i + "].mesh") ($mesh + ".inMesh");

        string $transform = getTransformNode($mesh);
        $transforms[size($transforms)] = $transform;
        connectAttr ($asset + ".output[" + $i + "].transform.translate") ($transform + ".translate");
        connectAttr ($asset + ".output[" + $i + "].transform.rotate") ($transform + ".rotate");
        connectAttr ($asset + ".output[" + $i + "].transform.scale") ($transform + ".scale");

        string $tmp = "assignCreatedShader %type \"" + $mesh + "\" %node \"" + $mesh + "\"";
        createRenderNodeCB -asShader "surfaceShader" phong $tmp;

        int $matExists = `getAttr ($asset + ".output[" + $i + "].materialExists")`;
        if ($matExists)
        {
            string $material = getMaterialNode($mesh);
            connectAttr ($asset + ".output[" + $i + "].material.specularColor") ($material + ".specularColor");

            string $texturePath= `getAttr ($asset + ".output[" + $i + "].texturePath")`;
            if ($texturePath == "")
            {
                connectAttr ($asset + ".output[" + $i + "].material.ambientColor") ($material + ".ambientColor");
                connectAttr ($asset + ".output[" + $i + "].material.diffuseColor") ($material + ".color");
            } else
            {
                string $fileNode = `createRenderNodeCB -as2DTexture "" "file" ""`;
                connectAttr ($asset + ".output[" + $i + "].material.texturePath")($fileNode + ".fileTextureName");
                connectAttr ($fileNode + ".outColor") ($material + ".color");
            }
        }

    }

    if ($numObjects <= 0)
        return;

    // group the objects to be under one transform
    string $cmd = "group -n " + $asset + "Transform";
    for ($i=0; $i<size($transforms); $i++) {
        $cmd += " ";
        $cmd += $transforms[$i];
    }
    eval $cmd;

    refreshEditorTemplates;

}

