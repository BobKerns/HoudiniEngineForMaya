source createAndAssignShader;

proc string getTransformNode( string $shape )
{
    string $transform = "";

    string $parents[] = `listRelatives -parent -fullPath $shape`;
    if (size($parents) >= 1)
        $transform = $parents[0];

    return $transform;
    //if ($transform == "")
        //return $transform;
    //return `substring $transform 2 (size($transform))`;
}


proc string getMaterialNode(string $shape)
{
    string $SGs[] = `listConnections -type shadingEngine $shape`;
    string $surfaceShader[] = `listConnections ($SGs[0] + ".surfaceShader")`;
    return $surfaceShader[0];
}


proc string[] getRelatedNodes(string $shape)
{
    string $ret[];
    if ($shape != "")
        $ret[size($ret)] = $shape;

    string $mat = getMaterialNode($shape);
    if ($mat != "")
        $ret[size($ret)] = $mat;

    string $trans = getTransformNode($shape);
    if ($trans != "")
        $ret[size($ret)] = $trans;

    string $tt = getTransformNode($trans);
    print "relatives: ";
    print(size(`listRelatives -children $tt`));
    print "\n";
    if ($tt != "")
        if (size(`listRelatives -children $tt`) <= 1)
            $ret[size($ret)] = $tt;

    string $tmp[] = `listConnections -s false -type shadingEngine ($mat + ".outColor")`;
    if (size($tmp) > 0)
        $ret[size($ret)] = $tmp[0];

    $tmp = `listConnections -d false -type file ($mat + ".color")`;
    if (size($tmp) > 0)
    {
        string $file = $tmp[0];
        $ret[size($ret)] = $file;
        $tmp = `listConnections -d false -type place2dTexture $file`;
        if (size($tmp) > 0)
            $ret[size($ret)] = $tmp[0];
    }
    return $ret;
}


proc disconnectFromObjects(string $objects[])
{
    for ($i=0; $i<size($objects); $i++)
    {
        string $plugs[] = `listConnections -sh true -d false -plugs true $objects[$i]`;
        for ($j=0; $j<size($plugs); $j++)
        {
            string $otherPlugs[] = `connectionInfo -dfs $plugs[$j]`;
            for ($k=0; $k<size($otherPlugs); $k++)
                disconnectAttr $plugs[$j] $otherPlugs[$k];
        }
    }
}


global proc string makeAsset(string $fileName) {
    string $tmpArray[] = stringToStringArray($fileName, "/");
    string $tmpStr = $tmpArray[size($tmpArray)-1];
    $tmpArray = stringToStringArray($tmpStr, ".");
    string $asset = $tmpArray[0] + "_asset";
    $asset = `createNode hAsset -n $asset`;
    setAttr -type "string" ($asset + ".fileName") $fileName;
    setAttr -lock on ($asset + ".fileName");


    // hack to get node to compute
    // TODO: move initialization to postConstructor
    getAttr ($asset + ".output");
    int $numObjects = `getAttr -size ($asset + ".objects")`;

    // connect the time node
    connectAttr "time1.outTime" ($asset + ".inTime");

    //string $group = $asset + "_transform";
    //group -n $group -em;

    updateAsset($asset, $numObjects);

    refreshEditorTemplates;

    return $asset;
}


global proc updateAsset(string $asset, int $numObjects)
{
    if (!`objExists $asset`)
        return;

    if (`getAttr ($asset + ".fileName")` == "")
        return;

    print "updated asset: ";
    print ($asset + "\n");

    print ($numObjects + "\n");

    int $assetType = `getAttr ($asset + ".typ")`;
    if ($assetType == 1)
    {
        // SOP asset
        print "SOP Asset\n";
        return;
    }

    //string $transforms[] = {};
    string $meshes[] = {};

    for ($i=0; $i<$numObjects; $i++) {
        string $obj = $asset + ".objects[" + $i + "]";
        string $meshName= `getAttr ($obj + ".objectName")`;

        string $buffer[];
        int $numTokens = tokenize($meshName, "_", $buffer);
        string $objName = "";
        if ($numTokens > 1)
            $objName += $buffer[0];
            for ($j=1; $j<$numTokens-1; $j++)
                $objName = $objName + "_" + $buffer[$j];

        string $outCons[] = `connectionInfo -dfs ($obj + ".mesh")`;
        string $connectedMeshes[] = `listConnections -s false -t "mesh" -sh true $asset`;
        if (size($outCons) == 1)
        {
            string $outMesh = longNameOf(`plugNode $outCons[0]`);
            string $outT = `substitute "Shape" $meshName ""`;
            print ($outMesh + "\n");
            string $t = getTransformNode($outMesh);
            print ($t + "\n");
            string $tt = getTransformNode(longNameOf($t));
            print ($tt + "\n");
            print ($outT + "\n");
            print ($objName + "\n");
            if (shortNameOf($t) != $outT)
                rename $t $outT;
            if (`objExists $objName` && shortNameOf($tt) != $objName)
                rename $objName "dummy";
            if (shortNameOf($tt) != $objName)
                rename $tt $objName;


        }

    }

    for ($i=0; $i<$numObjects; $i++) {

        print ("++++++++ loop: " + $i + "\n");

        string $obj = $asset + ".objects[" + $i + "]";
        string $meshName= `getAttr ($obj + ".objectName")`;
        $meshes[size($meshes)] = $meshName;
        print ("meshName: " + $meshName + "\n");


        string $buffer[];
        int $numTokens = tokenize($meshName, "_", $buffer);
        string $objName = "";
        print $buffer;
        print "\n";
        if ($numTokens > 1)
            $objName += $buffer[0];
            for ($j=1; $j<$numTokens-1; $j++)
                $objName = $objName + "_" + $buffer[$j];

        string $mesh = $meshName;


        // If have outgoing connection on mesh, it should be handled already
        string $outCons[] = `connectionInfo -dfs ($obj + ".mesh")`;
        if (size($outCons) == 1)
        {
            continue;
        }

        // If mesh node name exists, user must have disconnected it, so we don't do anything
        if (`objExists $mesh`)
        {
            continue;
        }

        // Otherwise, the plug is not connected, and mesh does not exist, so create a node and
        // connect things.
        createNode mesh -n $mesh;
        print ("----------------- createded mesh: " + $mesh + "\n");
        connectAttr -f ($obj + ".mesh") ($mesh + ".inMesh");

        string $transform = getTransformNode($mesh);
        print ("transform: " + $transform + " objName: " + $objName + "\n");

        connectAttr -f ($obj + ".transform.translate") ($transform + ".translate");
        connectAttr -f ($obj + ".transform.rotate") ($transform + ".rotate");
        connectAttr -f ($obj + ".transform.scale") ($transform + ".scale");

        //string $tmp = "assignCreatedShader %type \"" + $mesh + "\" %node \"" + $mesh + "\"";
        //createRenderNodeCB -asShader "surfaceShader" phong $tmp;
        string $phong = `shadingNode -asShader phong`;
        select -r $mesh;
        hyperShade -assign $phong;

        int $matExists = `getAttr ($obj + ".materialExists")`;
        if ($matExists)
        {
            string $material = getMaterialNode($mesh);
            connectAttr -f ($obj + ".material.specularColor") ($material + ".specularColor");
            connectAttr -f ($obj + ".material.alphaColor") ($material + ".transparency");

            string $texturePath= `getAttr ($asset + ".objects[" + $i + "].texturePath")`;
            if ($texturePath == "")
            {
                connectAttr -f ($obj + ".material.ambientColor") ($material + ".ambientColor");
                connectAttr -f ($obj + ".material.diffuseColor") ($material + ".color");
            } else
            {
                //string $fileNode = `createRenderNodeCB -as2DTexture "" "file" ""`;
                string $fileNode = `shadingNode -asTexture file`;
                connectAttr -f ($obj + ".material.texturePath")($fileNode + ".fileTextureName");
                connectAttr -f ($fileNode + ".outColor") ($material + ".color");
            }
        }

        if (!`objExists $objName`)
            group -n $objName -em;
        if (!isParentOf($objName, $transform))
            parent $transform $objName;

        string $group = $asset + "_transform";
        if (!`objExists $group`)
            group -n $group -em;
        if (!isParentOf($group, $objName))
            parent $objName $group;

    }

    //string $connectedObjs[] = `listConnections -s false -t "mesh" $asset`;
    string $connectedMeshes[] = `listConnections -s false -t "mesh" -sh true $asset`;
    int $numOutCons = size($connectedMeshes);
    for ($i=$numObjects; $i<$numOutCons; $i++)
    {
        string $mesh = $connectedMeshes[$i];
        string $related[] = getRelatedNodes($mesh);
        print "related: ";
        print $related;
        print "\n";
        disconnectFromObjects($related);
        for ($j=0; $j<size($related); $j++)
        {
            delete $related[$j];
        }
    }

    int $numInstancers = `getAttr -size ($asset + ".instancers")`;
    for ($i=0; $i<$numInstancers; $i++) {
        string $instAttr = $asset + ".instancers[" + $i + "]";
        string $instancer = $asset + "_instancer#";
        if (size(`connectionInfo -dfs ($instAttr + ".instancerData")`) > 0)
        {
            continue;
        }
        $instancer = `createNode instancer -n $instancer`;
        //$objects[size($objects)] = $instancer;
        setAttr ($instancer + ".rotationAngleUnits") 1;
        connectAttr -f ($instAttr + ".instancerData") ($instancer + ".inputPoints");

        int $numInstObjNames = `getAttr -size ($instAttr + ".ion")`;
        for ($j=0; $j<$numInstObjNames; $j++) {
            string $obj = `getAttr ($instAttr + ".ion[" + $j + "]")`;
            connectAttr -f ($obj + ".matrix") ($instancer + ".inputHierarchy[" + $j + "]");
            hide $obj;
        }

        string $group = $asset + "_transform";
        if (!isParentOf($group, $instancer))
            parent $instancer $group;
        if (!`objExists $group`)
            group -n $group -em;
    }

    select -r $asset;
}
